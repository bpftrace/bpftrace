NAME map one key
PROG begin { @map[16] = 32; @map[64] = 128; for ($kv : @map) { print($kv); }  }
EXPECT (16, 32)
EXPECT (64, 128)

NAME map two keys with a per cpu aggregation
REQUIRES_FEATURE lookup_percpu_elem
PROG begin { @map[16,17] = count(); @map[16,17] = count(); @map[1,2] = count(); for ($kv : @map) { print($kv); }  }
EXPECT ((16, 17), 2)
EXPECT ((1, 2), 1)

NAME map stack key with a per cpu aggregation
REQUIRES_FEATURE lookup_percpu_elem
PROG begin { @map[kstack(raw)] = count(); for ($kv : @map) { print($kv.1); }  }
EXPECT 1

NAME map with break
PROG begin { @map["foo"] = 1; @map["bar"] = 2; print("start"); for ($i : @map) { print($i.0); break; } print("done");  }
EXPECT_REGEX .*start\n(foo|bar)\ndone\n\n

NAME map with continue
PROG begin { @map["foo"] = 1; @map["bar"] = 2; print("start"); for ($i : @map) { if ($i.0 == "bar") { continue; } print($i.0); }  }
EXPECT_REGEX .*start\nfoo\n\n

NAME range basic
PROG begin { for ($i : 0..5) { print($i); }  }
EXPECT_REGEX .*\n0\n1\n2\n3\n4\n\n

NAME range with variables
PROG begin { $start = 2; $end = 7; for ($i : $start..$end) { print($i); }  }
EXPECT_REGEX .*\n2\n3\n4\n5\n6\n\n

NAME range with expressions
PROG begin { for ($i : (1+1)..(2*4)) { print($i); }  }
EXPECT_REGEX .*\n2\n3\n4\n5\n6\n7\n\n

NAME range with map as expression
PROG begin { @map[5] = 8; for ($i : 0..@map[5]) { print($i); }  }
EXPECT_REGEX .*\n2\n3\n4\n5\n6\n7\n\n

NAME range with zero iterations
PROG begin { for ($i : 1..0) { print("here"); }  }
EXPECT_NONE here

NAME range with negative start
PROG begin { for ($i : (-3)..3) { print($i); }  }
EXPECT_REGEX .*\n-3\n-2\n-1\n0\n1\n2\n\n

NAME range with same start and end
PROG begin { for ($i : 5..5) { print("here"); }  }
EXPECT_NONE here

NAME range with variable modification
PROG begin { $sum = 0; for ($i : 1..5) { $sum += $i; } print($sum);  }
EXPECT_REGEX ^10

NAME range using a map
PROG begin { @a = 10; for ($i : 0..@a) { print($i); @a += 1; }  }
EXPECT_REGEX @a: 20

NAME range with break
PROG begin { for ($i : 1..4) { if ($i == 2) { break; } print($i); } print("5");  }
EXPECT_REGEX .*\n1\n5\n\n

NAME range with continue
PROG begin { for ($i : 1..4) { if ($i == 2) { continue; } print($i); }  }
EXPECT_REGEX .*\n1\n3\n\n

NAME external function call map
PROG begin { @map[1] = 1; $x = 1; for ($kv : @map) { print(has_key(@map, $x)); }  }
EXPECT true

NAME external function call range
PROG begin { @map[1] = 1; $x = 1; for ($i : 0..1) { print(has_key(@map, $x)); }  }
EXPECT true
