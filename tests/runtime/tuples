NAME tuple print
PROG begin { @ = (1, 2, "string", (4, 5));  }
EXPECT @: (1, 2, string, (4, 5))

NAME struct in tuple
PROG struct Foo { int m; int n; } u:./testprogs/simple_struct:func { @t = (1, *((struct Foo *)arg0)); exit(); }
EXPECT @t: (1, { .m = 2, .n = 3 })
AFTER ./testprogs/simple_struct

NAME struct in tuple sizing
PROG struct Foo { int m; int n; } u:./testprogs/simple_struct:func { $t = ((int32)1, *((struct Foo *)arg0)); print(sizeof($t)); exit(); }
EXPECT 12
AFTER ./testprogs/simple_struct

NAME array in tuple
PROG struct A { int x[4]; } u:./testprogs/array_access:test_struct { @t = (1, ((struct A *)arg0).x); exit(); }
EXPECT @t: (1, [1,2,3,4])
AFTER ./testprogs/array_access

NAME array in tuple sizing
PROG struct A { int x[4]; } u:./testprogs/array_access:test_struct { $t = ((int32)1, ((struct A *)arg0).x); print(sizeof($t)); exit(); }
EXPECT 20
AFTER ./testprogs/array_access

NAME array-style tuple access
PROG begin{ $a = (1, 2, 3); print($a[1 + 1]); }
EXPECT 3

NAME nested tuple
PROG begin{ @ = ((int8)1, ((int8)-20, (int8)30)); exit(); }
EXPECT @: (1, (-20, 30))

# Careful with '(' and ')', they are read by the test engine as a regex group,
# so make sure to escape them.
NAME tuple print
PROG begin { @ = (1, 2, "string", (4, 5));  }
EXPECT @: (1, 2, string, (4, 5))

NAME tuple strftime type is packed
PROG begin { @ = (nsecs, strftime("%M:%S", nsecs));  }
EXPECT_REGEX ^@: \(\d+, \d+:\d+\)$

NAME bytearray in tuple
PROG uprobe:./testprogs/uprobe_test:uprobeFunction1 { @ = ((int8)1, usym(reg("ip")), 10); exit(); }
EXPECT_REGEX ^@: \(1, uprobeFunction1, 10\)$
ARCH x86_64
AFTER ./testprogs/uprobe_test

NAME bytearray in tuple
PROG uprobe:./testprogs/uprobe_test:uprobeFunction1 { @ = ((int8)1, usym(reg("nip")), 10); exit(); }
EXPECT_REGEX ^@: \(1, uprobeFunction1, 10\)$
ARCH ppc64|ppc64le
AFTER ./testprogs/uprobe_test

NAME ustack in tuple
PROG begin { print((ustack, "a"));  }
EXPECT Attached 1 probe

NAME kstack in tuple
PROG begin { print((kstack, "a"));  }
EXPECT Attached 1 probe

NAME tuple binop equals
PROG begin { $x = ("hello", -6); $y = ("hello", -6); $a = (1, true, $x); @b = (1, true, $y); if ($a == @b) { printf("ok\n"); } if ($a == (1, true, ("ello", -6))) { printf("nok\n"); } }
EXPECT ok
EXPECT_NONE nok

NAME tuple binop not equals
PROG begin { $x = ("hello", -6); $y = ("hello", -6); $a = (1, true, $x); @b = (1, true, $y); if ($a != @b) { printf("nok\n"); } if ($a != (1, true, ("ello", -6))) { printf("ok\n"); } }
EXPECT ok
EXPECT_NONE nok
