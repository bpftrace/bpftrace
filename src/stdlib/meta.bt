// :variant bool is_str(any expression)
// Determine whether the given expression is a string.
macro is_str(expr) {
  typeinfo(expr).1 == "string"
}

// :variant bool is_ptr(any expression)
// Determine whether the given expression is a pointer.
macro is_ptr(expr) {
  typeinfo(expr).1 == "pointer"
}

// :variant bool is_array(any expression)
// Determine whether the given expression is an array.
macro is_array(expr) {
  typeinfo(expr).1 == "array"
}

// :variant bool is_integer(any expression)
// Determine whether the given expression is an integer.
macro is_integer(expr) {
  typeinfo(expr).1 == "int"
}

// :variant void static_assert(bool condition, string msg)
// Assert something is true or fail the build.
macro static_assert(cond, msg) {
  if comptime !cond {
    fail(msg);
  }
}

macro check_key(@map, key, func) {
  if comptime is_scalar(@map) {
    fail("call to %s expects a map with explicit keys (non-scalar map)", func);
  } else {
    // The typeinfo(@map[key]) is a bit of a hack as it both checks if the passed key is compatible
    // with the map key and it also possibly changes the key type to make them
    // compatible if possible, e.g.
    // @c[1, ("hello", (int8)5)] = 0;
    // has_key(@c, (1, ("hello", (uint8)5))) - now the key type is (uint8, (string, int16))
    // Other than that this has no side effects and shouldn't fail
    if comptime (typeinfo(@map[key]).1 == "__dummy_key_type") {
      fail("__dummy_key_type shouldn't exist")
    }
  }
}

macro usdt_arg(x) {
   __usdt_arg((void *)ctx, x)
}
