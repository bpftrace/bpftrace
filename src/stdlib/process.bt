macro __signal(expr, is_tid)
{
  import "stdlib/process/process.bpf.c";
  let $sig : uint64 = 0;

  if comptime (probetype != "kprobe" && probetype != "kretprobe" &&
               probetype != "uprobe" && probetype != "uretprobe" &&
               probetype != "usdt" && probetype != "tracepoint" &&
               probetype != "profile" && probetype != "fentry" &&
               probetype != "fexit" && probetype != "rawtracepoint") {
    fail("%s can not be used for this probetype %s",
         is_tid ? "signal_thread()" : "signal()", probetype);
  }

  if comptime __builtin_safe_mode {
    fail("%s is unsafe. To use you need the --unsafe flag",
         is_tid ? "signal_thread()" : "signal()");
  } else if comptime is_literal(expr) {
    if comptime is_str(expr) {
      $sig = __builtin_signal_num(expr);
    } else if comptime is_integer(expr) {
      if comptime (expr < 1 || expr > 64) {
        fail("%s accepts a string literal or an integer between 1 and 64 (inclusive)",
             is_tid ? "signal_thread()" : "signal()");
      } else {
        $sig = expr;
      }
    } else {
      fail("%s accepts a string literal or a positive integer",
           is_tid ? "signal_thread()" : "signal()");
    }
  } else if comptime (!is_unsigned_integer(expr)) {
    fail("%s accepts a string literal or a unsigned integer",
         is_tid ? "signal_thread()" : "signal()");
  } else {
    $sig = expr;
  }

  if ($sig == 0 || $sig > 64) {
    errorf("%s expects an integer between 1 and 64 (inclusive). Got %d",
           is_tid ? "signal_thread()" : "signal()", $sig);
  } else {
    $ret = comptime is_tid
           ? __signal_thread((uint32)$sig)
           : __signal_process((uint32)$sig);
    if ($ret != 0) {
      warnf("signal call failed with error %d", $ret);
    }
  }
}

// :variant uint64 curtask()
// Pointer to `struct task_struct` of the current task
//
// This utilizes the BPF helper `get_current_task`
macro curtask() {
  import "stdlib/process/task.bpf.c";
  __get_current_task()
}

// :function pid
// :variant uint32 pid([curr_ns|init])
// :variant uint32 pid
//
// Returns the process ID of the current thread.
// Defaults to `curr_ns`.
//
// * `pid(curr_ns)` - The process ID as seen from the PID namespace of bpftrace.
// * `pid(init)` - The process ID as seen from the initial PID namespace.

// :variant uint32 ppid()
// :variant uint32 ppid(struct task_struct * task)
// Get the pid of the parent process for the passed task or the current task if called without arguments.
macro ppid(task)
{
  task.real_parent.pid
}

macro ppid()
{
  ppid(curtask)
}

// :variant string pcomm()
// :variant string pcomm(struct task_struct * task)
// Get the name of the process for the passed task or the current task if called without arguments. This is an alias for (task->group_leader->comm).
macro pcomm(task)
{
  task.group_leader.comm
}

macro pcomm()
{
  pcomm(curtask)
}
