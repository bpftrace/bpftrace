// :variant int64 strcontains(const char *haystack, const char *needle)
// Compares whether the string haystack contains the string needle.
//
// If needle is contained then true is returned, else false is returned.
//
// Note that the passed expressions are always reified as strings, so may be
// copied into BPF memory.
macro strcontains(haystack, needle) {
  // Accept anything that `str` accepts, but not integers.
  if (comptime typeinfo(haystack) == typeinfo(1) || typeinfo(haystack) == typeinfo(-1) ||
               typeinfo(needle) == typeinfo(1) || typeinfo(needle) == typeinfo(-1)) {
    fail("strcontains requires pointers or strings");
  }
  let $haystack = str(haystack);
  let $needle = str(needle);
  let $found = false;
  if (sizeof($needle) == 0 || $needle[0] == 0) {
    // Special case: the needle is zero-sized.
    $found = true;
  } else {
    for ($i : ((uint64)0)..sizeof($haystack)) {
      // Help the verifier know this is safe.
      if ($i >= sizeof($haystack)) {
        break;
      }
      if ($haystack[$i] == 0) {
        break;
      }
      for ($j : ((uint64)0)..sizeof($needle)) {
        // Help the verifier know this is safe.
        if ($j >= sizeof($needle)) {
          break;
        }
        if ($needle[$j] == 0) {
          $found = true;
          break;
        }
        let $k = $i + $j;
        // Help the verifier a bit more.
        if ($k >= sizeof($haystack)) {
          break;
        }
        if ($haystack[$k] != $needle[$j]) {
          break;
        }
      }
      if ($found) {
        break;
      }
    }
  }
  $found
}
