#include "bpfprogram.h"

#include "bpfbytecode.h"
#include "bpftrace.h"
#include "log.h"
#include "utils.h"

#include <bpf/bpf.h>
#include <cstdint>
#include <elf.h>
#include <linux/bpf.h>
#include <linux/btf.h>
#include <optional>
#include <stdexcept>
#include <tuple>

namespace bpftrace {

// We currently support building against really old
// kernel/elf headers. These defines provide the information
// that might be missing and are a stopgap until a high
// enough libbpf is a requirement and this code can be removed.

#ifndef R_BPF_64_64
#define R_BPF_64_64 1
#endif

#ifndef BPF_PSEUDO_FUNC
#define BPF_PSEUDO_FUNC 4
#endif

struct btf_ext_header {
  __u16 magic;
  __u8 version;
  __u8 flags;
  __u32 hdr_len;

  /* All offsets are in bytes relative to the end of this header */
  __u32 func_info_off;
  __u32 func_info_len;
};

struct btf_ext_info_sec {
  __u32 sec_name_off; /* offset to section name */
  __u32 num_info;
  /* Followed by num_info * record_size number of bytes */
  __u8 data[0];
};

BpfProgram::BpfProgram(struct bpf_program *bpf_prog) : bpf_prog_(bpf_prog)
{
}

const std::vector<uint8_t> &BpfProgram::getCode() const
{
  return code_;
}

const std::vector<uint8_t> &BpfProgram::getFuncInfos() const
{
  return func_infos_;
}

int BpfProgram::fd() const
{
  return fd_;
}

void BpfProgram::assemble(const BpfBytecode &bytecode)
{
  if (!code_.empty())
    return;

  code_ = bytecode.getSection(bpf_program__section_name(bpf_prog_));

  relocateInsns(bytecode);
}

// Instruction relocations assume BPF ELF structure as generated by LLVM.
// This is not standardized, yet, but there is an effort in place [1]. Still,
// the structure is already assumed by many tools (most importantly libbpf [2])
// and therefore is very unlikely to change in a breaking manner. With respect
// to that, we assume certain properties (e.g. offsets validity) and omit some
// explicit checks that would just pollute the code. Additionally, once we move
// towards libbpf-based loading and attachment, all this code will go away.
//
// [1] https://www.ietf.org/archive/id/draft-thaler-bpf-elf-00.html
// [2] https://libbpf.readthedocs.io/en/latest/program_types.html
void BpfProgram::relocateInsns(const BpfBytecode &bytecode)
{
  auto section_name = bpf_program__section_name(bpf_prog_);
  std::string relsecname = std::string(".rel") + section_name;
  // Step 1: relocate our program
  relocateSection(relsecname,
                  reinterpret_cast<struct bpf_insn *>(code_.data()),
                  bytecode);

  if (text_offset_ > 0) {
    // Step 2: append .text if necessary.
    auto &text = bytecode.getSection(".text");
    code_.insert(code_.end(), text.begin(), text.end());

    // Step 3: relocate .text, if necessary.
    relocateSection(".rel.text",
                    reinterpret_cast<struct bpf_insn *>(code_.data() +
                                                        text_offset_),
                    bytecode);
  }

  // Step 4: deal with bpf_func_infos.
  relocateFuncInfos(bytecode);
}

void BpfProgram::relocateSection(const std::string &relsecname,
                                 bpf_insn *insns,
                                 const BpfBytecode &bytecode)
{
  if (!bytecode.hasSection(relsecname))
    return;

  // There's a relocation section for our program.
  //
  // Relocation support is incomplete, only ld_imm64 + R_BPF_64_64 is
  // supported to make pointers to subprog callbacks possible.
  //
  // In practice, we append the entire .text section and relocate against it.

  if (!bytecode.hasSection(".text")) {
    throw std::logic_error(
        "Relocation section present but no .text, this is unsupported");
  }
  auto &relsec = bytecode.getSection(relsecname);
  auto &symtab = bytecode.getSection(".symtab");
  auto &strtab = bytecode.getSection(".strtab");

  for (auto *ptr = relsec.data(); ptr < relsec.data() + relsec.size();
       ptr += sizeof(Elf64_Rel)) {
    auto *rel = reinterpret_cast<const Elf64_Rel *>(ptr);
    uint32_t reltype = rel->r_info & 0xFFFFFFFF;
    uint32_t relsym = rel->r_info >> 32;

    if (reltype != R_BPF_64_64)
      throw std::invalid_argument("Unsupported relocation type");

    auto rel_offset = rel->r_offset;
    auto insn_offset = rel_offset / sizeof(struct bpf_insn);
    auto *insn = &insns[insn_offset];
    if (insn->code != (BPF_LD | BPF_DW | BPF_IMM)) {
      LOG(ERROR) << "Cannot relocate insn code " << insn->code << " ld "
                 << (insn->code & BPF_LD) << " dw " << (insn->code & BPF_DW)
                 << " imm " << (insn->code & BPF_IMM);
      throw std::invalid_argument("Unsupported relocated instruction");
    }

    auto *sym = &reinterpret_cast<const Elf64_Sym *>(symtab.data())[relsym];
    auto symtype = ELF64_ST_TYPE(sym->st_info);
    if (symtype == STT_FUNC || symtype == STT_SECTION) {
      // We will append .text to code_ and we assume that sym->st_shndx
      // corresponds to .text, therefore symbol value is an offset from
      // code_.size().
      //
      // Relocate via direct instruction manipulation instead of the
      // relocation entry for readability purposes.
      //
      // This is a hack. We shouldn't do this. However, we don't actually have
      // the ELF section table to determine if the relocation actually refers
      // to .text
      if (text_offset_ == 0)
        text_offset_ = code_.size();

      // An offset to .text must be added when relocating instructions from the
      // main program that point into .text.
      // No offset is needed when relocating instructions from .text that point
      // to another part of .text.
      const auto text_relative_offset = (relsecname == ".rel.text")
                                            ? 0
                                            : text_offset_;

      auto target_insn = (text_relative_offset + sym->st_value + insn->imm) /
                         sizeof(struct bpf_insn);
      insn->src_reg = BPF_PSEUDO_FUNC;
      insn->imm = (target_insn - insn_offset - 1); // jump offset
    } else if (symtype == STT_OBJECT) {
      std::string map_name = bpftrace_map_name(
          reinterpret_cast<const char *>(strtab.data() + sym->st_name));

      const auto &map = bytecode.getMap(map_name);
      insn->src_reg = map.bpf_name() == to_string(MapType::MappedPrintfData)
                          ? BPF_PSEUDO_MAP_VALUE
                          : BPF_PSEUDO_MAP_FD;
      insn->imm = static_cast<int32_t>(map.fd);
    } else {
      LOG(ERROR) << "Relocation in " << relsecname << " type " << reltype
                 << " sym " << relsym << " type " << symtype;
      throw std::invalid_argument(
          "Unsupported symbol type referenced in relocation");
    }
  }
}

// Assumed structure:
//
// code_[0..text_offset_) - program
// code_[text_offset_..code_.size()) - .text
void BpfProgram::relocateFuncInfos(const BpfBytecode &bytecode)
{
  if (!bytecode.hasSection(".BTF") || !bytecode.hasSection(".BTF.ext")) {
    throw std::logic_error("Missing a BTF section (.BTF or .BTF.ext), "
                           "cannot relocate function infos");
  }

  const auto *btfsec = bytecode.getSection(".BTF").data();
  auto *btfhdr = reinterpret_cast<const struct btf_header *>(btfsec);
  auto *btfstr = btfsec + btfhdr->hdr_len + btfhdr->str_off;

  const auto *btfextsec = bytecode.getSection(".BTF.ext").data();

  auto *exthdr = reinterpret_cast<const struct btf_ext_header *>(btfextsec);
  auto *exthdr_end = btfextsec + exthdr->hdr_len;
  auto *func_info_end = exthdr_end + exthdr->func_info_len;

  auto *ptr = exthdr_end + exthdr->func_info_off;

  auto func_info_rec_size = *reinterpret_cast<const __u32 *>(ptr);
  if (sizeof(bpf_func_info) > func_info_rec_size)
    throw std::invalid_argument("Unsupported bpf_func_info size");
  ptr += sizeof(__u32);

  // We need to find the bpf_ext_info_secs for our program section and,
  // optionally, for .text. They're likely not in the order we need them in,
  // so find them first, then copy things over, so we keep the invariant that
  // the first func_info is for the function at offset 0.
  const btf_ext_info_sec *text_funcinfo_sec = nullptr;
  const btf_ext_info_sec *prog_funcinfo_sec = nullptr;

  while (ptr < func_info_end) {
    auto *info_sec = reinterpret_cast<const struct btf_ext_info_sec *>(ptr);
    std::string_view name = reinterpret_cast<const char *>(
        btfstr + info_sec->sec_name_off);
    if (text_offset_ > 0 && name == ".text")
      text_funcinfo_sec = info_sec;
    else if (name == bpf_program__section_name(bpf_prog_))
      prog_funcinfo_sec = info_sec;

    ptr += sizeof(struct btf_ext_info_sec) +
           (uintptr_t)info_sec->num_info * func_info_rec_size;
  }

  if (prog_funcinfo_sec == nullptr)
    throw std::invalid_argument("Missing btf_ext_info_sec for program section");
  if (text_offset_ > 0 && text_funcinfo_sec == nullptr)
    throw std::invalid_argument("Missing btf_ext_info_sec for .text section");

  appendFileFuncInfos(prog_funcinfo_sec, func_info_rec_size, 0);
  if (text_offset_ > 0)
    appendFileFuncInfos(text_funcinfo_sec,
                        func_info_rec_size,
                        text_offset_ / sizeof(bpf_insn));
}

// Copy all ELF func_infos from src and convert them to kernel
// bpf_func_infos, adding insn_off to the final value.
void BpfProgram::appendFileFuncInfos(const struct btf_ext_info_sec *src,
                                     size_t func_info_rec_size,
                                     size_t insn_off)
{
  auto *ptr = reinterpret_cast<const uint8_t *>(src);
  auto *hdr_end = ptr + sizeof(struct btf_ext_info_sec);
  auto cnt = src->num_info;

  size_t dstoff = func_infos_.size();
  func_infos_.resize(dstoff + cnt * sizeof(struct bpf_func_info));

  ptr = hdr_end;
  while (ptr < hdr_end + cnt * func_info_rec_size) {
    auto *src_info = reinterpret_cast<const struct bpf_func_info *>(ptr);
    auto *dst_info = reinterpret_cast<struct bpf_func_info *>(
        func_infos_.data() + dstoff);

    dst_info->type_id = src_info->type_id;
    dst_info->insn_off = (src_info->insn_off / sizeof(struct bpf_insn)) +
                         insn_off;

    dstoff += sizeof(struct bpf_func_info);
    ptr += func_info_rec_size;
  }
}

namespace {
/*
 * Searches the verifier's log for err_pattern. If a match is found, extracts
 * the name and ID of the problematic helper and throws a HelperVerifierError.
 *
 * Example verfier log extract:
 *     [...]
 *     36: (b7) r3 = 64                      ; R3_w=64
 *     37: (85) call bpf_d_path#147
 *     helper call is not allowed in probe
 *     [...]
 *
 *  In the above log, "bpf_d_path" is the helper's name and "147" is the ID.
 */
void maybe_throw_helper_verifier_error(std::string_view log,
                                       std::string_view err_pattern,
                                       const std::string &exception_msg_suffix)
{
  auto err_pos = log.find(err_pattern);
  if (err_pos == log.npos)
    return;

  std::string_view call_pattern = " call ";
  auto call_pos = log.rfind(call_pattern, err_pos);
  if (call_pos == log.npos)
    return;

  auto helper_begin = call_pos + call_pattern.size();
  auto hash_pos = log.find("#", helper_begin);
  if (hash_pos == log.npos)
    return;

  auto eol = log.find("\n", hash_pos + 1);
  if (eol == log.npos)
    return;

  auto helper_name = std::string{ log.substr(helper_begin,
                                             hash_pos - helper_begin) };
  auto func_id = std::stoi(
      std::string{ log.substr(hash_pos + 1, eol - hash_pos - 1) });

  std::string msg = std::string{ "helper " } + helper_name +
                    exception_msg_suffix;
  throw HelperVerifierError(msg, static_cast<libbpf::bpf_func_id>(func_id));
}
} // namespace

void BpfProgram::load(const Probe &probe,
                      const BpfBytecode &bytecode,
                      const BTF &btf,
                      BPFfeature &feature)
{
  auto &insns = getCode();
  auto func_infos = getFuncInfos();
  const char *license = "GPL";
  int log_level = 0;
  std::stringstream logbuf; // while stderr is silenced and for joining lines

  uint64_t log_buf_size = probe.log_size;
  auto log_buf = std::make_unique<char[]>(log_buf_size);
  std::string name;
  std::string tracing_type;

  /*
   * Fallbacks for kernels that don't cope well with func_infos and BTF, and may
   * check the program's kernel version. Try witout BTF and func_infos and when
   * needed, also pass the kernel version (try three different methods):
   */
  struct load_strategy {
    bool btf;
    bool func_infos;
    KernelVersionMethod kver;
  } load_configs[] = {
    { .btf = true, .func_infos = true, .kver = None },  // BTF and func_infos
    { .btf = true, .func_infos = false, .kver = None }, // BTF, no func_infos
    /* Fallbacks for Linux <5.0: No BTF and func_infos, with kernel version: */
    { .btf = false, .func_infos = false, .kver = vDSO }, // version from vDSO
    { .btf = false, .func_infos = false, .kver = UTS },  // version from uname
    { .btf = false, .func_infos = false, .kver = File }, // version from header
  };

  for (auto &load_config : load_configs) {
    // In debug mode, show full verifier log.
    // In verbose mode, only show verifier log for failures.
    if (bt_debug.find(DebugStage::Verifier) != bt_debug.end())
      log_level = 15;
    else if (bt_verbose)
      log_level = 1;

    if (probe.type == ProbeType::kprobe || probe.type == ProbeType::kretprobe) {
      // Use orig_name for program name so we get proper name for
      // wildcard probes, replace wildcards with '.'
      name = probe.orig_name;
      std::replace(name.begin(), name.end(), '*', '.');
    } else
      name = probe.name;

    // bpf_prog_load rejects some characters in probe names, so we clean them
    // start the name after the probe type, after ':'
    if (auto last_colon = name.rfind(':'); last_colon != std::string::npos)
      name = name.substr(last_colon + 1);
    name = sanitise_bpf_program_name(name);

    auto prog_type = progtype(probe.type);
    if (probe.type == ProbeType::special && !feature.has_raw_tp_special())
      prog_type = progtype(ProbeType::uprobe);

    BPFTRACE_LIBBPF_OPTS(bpf_prog_load_opts, opts);
    opts.log_buf = log_buf.get();
    opts.log_size = log_buf_size;
    opts.log_level = log_level;

    if (probe.type == ProbeType::kfunc)
      opts.expected_attach_type = static_cast<::bpf_attach_type>(
          libbpf::BPF_TRACE_FENTRY);
    else if (probe.type == ProbeType::kretfunc)
      opts.expected_attach_type = static_cast<::bpf_attach_type>(
          libbpf::BPF_TRACE_FEXIT);
    else if (probe.type == ProbeType::iter)
      opts.expected_attach_type = static_cast<::bpf_attach_type>(
          libbpf::BPF_TRACE_ITER);

    // We want to avoid kprobe_multi when a module is specified
    // because the BPF_TRACE_KPROBE_MULTI link type does not
    // currently support the `module:function` syntax.
    if ((probe.type == ProbeType::kprobe ||
         probe.type == ProbeType::kretprobe) &&
        feature.has_kprobe_multi() && !probe.funcs.empty() &&
        probe.path.empty())
      opts.expected_attach_type = static_cast<::bpf_attach_type>(
          libbpf::BPF_TRACE_KPROBE_MULTI);

    if ((probe.type == ProbeType::uprobe ||
         probe.type == ProbeType::uretprobe) &&
        feature.has_uprobe_multi() && !probe.funcs.empty())
      opts.expected_attach_type = static_cast<::bpf_attach_type>(
          libbpf::BPF_TRACE_UPROBE_MULTI);

    if (probe.type == ProbeType::kfunc || probe.type == ProbeType::kretfunc ||
        probe.type == ProbeType::iter) {
      std::string mod = probe.path;
      std::string fun = probe.attach_point;
      if (probe.type == ProbeType::iter)
        fun = "bpf_iter_" + fun;
      auto btf_id = btf.get_btf_id_fd(fun, mod);
      if (btf_id.first < 0) {
        std::string msg = "No BTF found for " + mod + ":" + fun;
        if (probe.orig_name != probe.name) {
          // one attachpoint in a multi-attachpoint (wildcard or list) probe
          // failed, print a warning but continue
          LOG(WARNING) << msg << ", skipping.";
          return;
        } else
          // explicit match failed, fail hard
          throw FatalUserException(msg);
      }

      opts.attach_btf_id = btf_id.first;
      opts.attach_btf_obj_fd = btf_id.second;
    } else {
      opts.kern_version = kernel_version(load_config.kver);
    }
    logbuf << std::endl
           << "load " << probe.name << (load_config.btf ? ", with BTF" : "")
           << (load_config.func_infos ? ", with func_infos" : "");
    if (opts.kern_version) {
      logbuf << ", version: " << ((opts.kern_version >> 16) & 0xFF) << "."
             << ((opts.kern_version >> 8) & 0xFF) << "."
             << (opts.kern_version & 0xFF);
    }

    {
      // Redirect stderr, so we don't get error messages from libbpf
      StderrSilencer silencer;
      if (bt_debug.find(DebugStage::Libbpf) == bt_debug.end())
        silencer.silence();

      int btf_fd = -1;
      if (load_config.btf) {
        BPFTRACE_LIBBPF_OPTS(bpf_btf_load_opts,
                             btf_opts,
                             .log_buf = log_buf.get(),
                             .log_level = static_cast<__u32>(log_level),
                             .log_size = static_cast<__u32>(log_buf_size), );

        auto &btf_sec = bytecode.getSection(".BTF");
        btf_fd = bpf_btf_load(btf_sec.data(), btf_sec.size(), &btf_opts);
        if (btf_fd < 0) {
          logbuf << ": BTF load failed";
          goto log_error; // and continue to the next load_config fallback
        }
        opts.prog_btf_fd = (__u32)btf_fd;
      }

      // Skip .BTF.ext func_info relocation on fallback for older kernels
      if (load_config.func_infos && !func_infos.empty()) {
        opts.func_info_rec_size = sizeof(struct bpf_func_info);
        opts.func_info = func_infos.data();
        opts.func_info_cnt = func_infos.size() / sizeof(struct bpf_func_info);
      }

      // Load the BPF program on BTF load success or on fallback without it
      if (!load_config.btf || btf_fd >= 0) {
        fd_ = bpf_prog_load(static_cast<::bpf_prog_type>(prog_type),
                            name.c_str(),
                            license,
                            reinterpret_cast<const struct bpf_insn *>(
                                insns.data()),
                            insns.size() / sizeof(struct bpf_insn),
                            &opts);
        if (btf_fd >= 0)
          close(btf_fd);
      }
    }

    if (opts.attach_btf_obj_fd > 0)
      close(opts.attach_btf_obj_fd);
    if (fd_ >= 0)
      break;
    logbuf << " = " << fd_ << ": " << std::strerror(-fd_);
  log_error:
    if (!logbuf.str().empty()) { // log the error of the failed attempt
      LOG(V1) << logbuf.str();
      logbuf.str("");
    }
  } // for (auto &load_config : load_configs): handle kernel features & versions

  if (!logbuf.str().empty()) {
    LOG(V1) << logbuf.str() << ": Success";
  }

  if (fd_ < 0) {
    if (bt_verbose) {
      std::cerr << std::endl
                << "Error log: " << std::endl
                << log_buf.get() << std::endl;
      if (errno == ENOSPC) {
        throw FatalUserException(
            "Error: Failed to load program, verification log buffer not big "
            "enough, try increasing the BPFTRACE_LOG_SIZE environment variable "
            "beyond the current value of " +
            std::to_string(probe.log_size) + " bytes");
      }
    }

    maybe_throw_helper_verifier_error(log_buf.get(),
                                      "helper call is not allowed in probe",
                                      " not allowed in probe");

    std::stringstream errmsg;
    errmsg << "Error loading program: " << probe.name
           << (bt_verbose ? "" : " (try -v)");
    if (probe.orig_name != probe.name) {
      // one attachpoint in a multi-attachpoint (wildcard or list) probe failed,
      // print a warning but continue
      LOG(WARNING) << errmsg.str() << ", skipping.";
      return;
    } else
      // explicit match failed, fail hard
      throw FatalUserException(errmsg.str());
  }

  if (bt_verbose) {
    struct bpf_prog_info info = {};
    uint32_t info_len = sizeof(info);
    int ret;

    ret = bpf_obj_get_info(fd_, &info, &info_len);
    if (ret == 0) {
      std::cerr << std::endl << "Program ID: " << info.id << std::endl;
    }
  }

  if (bt_debug.find(DebugStage::Verifier) != bt_debug.end()) {
    std::cout << "BPF verifier log for " << probe.name << ":\n";
    std::cout << "--------------------------------------\n";
    std::cout << log_buf.get() << std::endl;
  }
}

} // namespace bpftrace
